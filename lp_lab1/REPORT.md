# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Попов.И.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   21.10      |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Пролог устроены так же, как и в императивных языках программирования, однако явно использовать указатели при работе с ними нет необходимости, так как в языке Пролог списки реализованы, как рекурсивная структура данных с последовательным доступом. Список в языке Пролог - это либо пустой элемент; либо один элемент, называемый головой, и присоединенный список — хвост. Списки очень удобны для использования в таких языках, где, подобно Прологу, неоходима древовидная структура. Несмотря на то, что сложность доступа к произвольному элементу в списках О(n), они выигрывают в памяти, так как список может храниться по отдельности в разных ячейках памяти.

## Задание 1.1: Предикат обработки списка

`count_occurrences(List, Element, Count)` - Предикат подсчитывает число вхождений заданного элемента в список

Примеры использования:
```prolog
?- count_occurrences([1,2,3,4,5,6,7,8,9,10],7,X).
X=1.
?- count_occurrences([1,2,2,6,7,8,2],2,X).
X=3.
```

Реализация:
```prolog
%Задание №1(Предикаты обработки списков)
%Вариант 18(Подсчет числа вхождений заданного элемента в список)
%Используя стандартный предикат findall
count_occurrences(List, Element, Count):-
  findall(Element, member(Element, List), Counters),
  length(Counters, Count).

%Без использования стандартных предикатов
count_occurrences([], _Element, 0):-!.
count_occurrences([Element|Tail], Element, Count):-!, count_occurrences(Tail, Element, CountTail),
  Count is CountTail + 1.
count_occurrences([_Element|Tail], Element, Count):-count_occurrences(Tail, Element, Count).
```

1. Способ на основе стандартных предикатов обработки списков
  
  a). с помощью `findall` создать список, состоящий только из искомых в изначальном списке элементов

  b). посчитать его длину

2. Без использования стандартных предикатов обработки списков
  
  a). При подсчете кол-ва вхождений элемента в список проверяется его начало, если в нем стоит искомый элемент счетчик увеличивается на 1, далее рекурсивно считаем вхождения в "хвосте" списка

## Задание 1.2: Предикат обработки числового списка

`max_element(List, X)` - Предикат вычисляет максимальный элемент списка

Примеры использования:
```prolog
?- max_element([1,2,3,4,5,6,7,8,9,10],X).
X=10.
?- max_element([1,5,3,6,7,8,2],X).
X=8.
```
Реализация:
```prolog
%Задание №2(Предикаты обработки числовых списков)
%Вариант 3(Вычисление максимального элемента)
%Используя стандартныe предикатs sort и last
max_element(List, X):-
    sort(List, L),
    last(L, X).

%Без использования стандартных предикатов
max_element([X],X).
max_element([H|Tail],H):-max_element(Tail,M),H>M,!.
max_element([_|Tail],M):-max_element(Tail,M).
```

1. Способ на основе стандартных предикатов обработки списков
  
  a). отсортировать список
  
  b). максимальный элемент будет являться последним элементом списка

2. Без использования стандартных предикатов обработки списков
  
  a). Если список из одного элемента, то максимальный - он сам
  
  b). Если в списке больше одного элемента, то список обрабатывается до конца, каждый элемент(стоящий в head списка) сравнивается с максимумом. 
  
  c). Если новый элемент больше нынешнего максимума, то этот новый элемент сам становится максимумом.
  
  d). Как только дошли до конца - возвращаем найденный максимум


## Задание 2: Реляционное представление данных

Как достоинством, так и недостатком реляционного представления данных является время доступа к тем или иным ячейкам памяти. Например, во 2 части лабораторной работы я использовал four.pl представление групп, и обращение к ученикам группы и к спискам оценок за предмет производилось за сложность, близкую к О(1), в то время как связывание учеников из определенной группы с их оценками представляло гораздо большую сложность.

1. Напечатать средний балл для каждого предмета
`average_mark(Sub,Mark)` - средний балл по предмету (Sub - предмет, Mark - средний балл)

 a). Ищется сумма оценок всех учеников по предмету
 
 b). Делется на количество этих оценок
 
 c). Получается средний балл по предмету
```
average_mark('Психология', X).
X = 3.857142857142857

average_mark('Логическое программирование', X).
X = 4.107142857142857
```
2. Для каждой группы, найти количество не сдавших студентов
`do_not_pass_group(Gr,Count)` - подсчет кол-ва учеников, не сдавших экзамен (Gr - заданная группа, Count -  количество не сдавших студентов)

  a). Создается список всех оценок учеников группы по всем предметам

  b). Из него исключаются дублирующиеся ученики (те, которые не сдали более одного предмета)

  c). Идет подсчет несдавших учеников из группы
```
do_not_pass_group(103,X).
X = 2

do_not_pass_group(101,X).
X = 3
```
3. Найти количество не сдавших студентов для каждого из предметов
`do_not_pass_sub(Sub,Count)` - кол-во студентов, не сдавших предмет (Sub - предмет, Count - количество не сдавших студентов)

  a). В списке оценок за предмет считаем только незачеты

```
do_not_pass_sub('Психология', X).
X = 2

do_not_pass_sub('Логическое программирование', X).
X = 3
```
## Выводы

Эта лабораторная работа была мои первым опытом написания кода на языке Пролог, я познакомился с синтаксисом языка, устройством и взаимодействию с главной стрктурой языка - списками. Также она дала мне понять, что навыки програмирования на императивных языках при работе с Прологом не представляют большой ценности, потому что языки сильно отличаются концептуально. Несмотря на это, Пролог - язык высокого уровня, и многие задачи на нем удается решать буквально в несколько строчек кода, что конечно же не может не радовать программистов. Отдельно хочется выделить предикаты пролога, которые напомнили мне перегруженные операторы из c++, их можно делать бесконечно много и использовать во многих своих проектах.
