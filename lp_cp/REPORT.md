# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Попов Илья Павлович

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Мне, как будущему программисту, недопустимо ограничивать себя лишь парадигмой императивного программирования, ведь многие задачи гораздо легче решить с помощью логических языков, таких как Prolog и Mercury. 

В результате этого курсового проекта будет решена реальная практическая задача, в которой использование логического языка является не просто одним из вариантов ее решения, а настоящей необходимостью.

В результате выполнения данного курсового проекта я хочу углубить свои знания и отточить навыки, связанные с парадигмой логического программирования и программированием на языке Prolog в частности. Также хорошей практикой будет написание парсера на языке высокого уровня, позволяющего легко проводить обработку текста - Python'е. 


## Задание

Стандартное задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате [GEDCOM](https://ru.wikipedia.org/wiki/GEDCOM). Для этого рекомендуется использовать сервис [MyHeritage.com](http://myheritage.com), зарегистрировавшись в нем и подключив к заполнению дерева других родственников (указав их контактный e-mail при регистрации, что приведет к автоматической рассылке приглашения на их адрес).
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog с использованием предикатов `father(отец, потомок)` и `mother(мать, потомок)`
 3. Реализовать предикат проверки/поиска золовки 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На более чем удовлетворительную оценку] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. Допускается использовать английский язык в качестве базового. Для отличной оценки требуется:

     а. Учесть контекст (возможность использования it/him/her с отсылкой на упомянутый на прошлом шаге объект)

     б. Выполнять запросы относительно количества (How many brothers does Mary have?)
     
     в. Выполнить разбор предложения с построением смысловой модели.

## Получение родословного дерева

Воспользовавшись сервисом [MyHeritage.com](http://myheritage.com) и помощью моих ближайших родственников, было построено генеалогическое дерево моей семьи, в нем насчитывается 83 человека.

## Конвертация родословного дерева

Конвертация родословного дерева из формата GED в файл, состоящий из фактов на языке Prolog производилась с помощью языка высокого уровня, позволяющего легко проводить обработку текста - Python'а.

``` Python
inp = open("input.ged", "r")
out = open("output.pl", "w")
```
Открыв файлы input.ged на чтение и output.pl на запись, программа начинает непосредственно парсинг.

``` Python
base = {}
```
Создаем словарь, которым будем пользоваться в дальнейшем для обеспечения доступа к полю "имя + фамилия" по ключу(id из ged-файла). Чтобы заполнить созданный словарь, необходимо считать имена и фамилии людей и соотнести их с id данного человека.

``` Python
for line in inp.readlines():#делим файл построчно
    words = line.split(" ") #делим строки по пробелам
 ```
 
Делим файл построчно, а сами строки - по словам. Так как первое слово в строке - ненужный номер поколения, чтение можно начинать со вторых слов в строках. Нужная нам информация содержится в строках по тегам "GIVN" и "SURN", а id обозначается буквой "I".
 
 ``` Python
 if len(words) >= 3:
        first = words[1] 
        second = words[2]
        
if second[0] == "I":
    key = first

elif first == "GIVN":
    name = second

elif first == "SURN":
    surn = second
    base.update({key:(name[:-1], surn[:-1])})
 ```
 Словарь заполнен.
 
По заданию требуется преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog с использованием предикатов father(отец, потомок) и mother(мать, потомок). Для этого из раздела информации о семье связываем по key родителя и ребенка.

 ``` Python
 elif first == "HUSB":
     husb = second

     for k, (n, s) in base.items():

         if k == husb[:-1]:
             father = n + " " + s

 elif first == "WIFE":
     wife = second

     for k, (n, s) in base.items():

         if k == wife[:-1]:
             mother = n + " " + s

 elif first == "CHIL":
     chil = second

     for k, (n, s) in base.items():

         if k == chil[:-1]:
             child = n + " " + s
  ```

Далле запишем в файл output.pl факты на языке пролог

 ``` Python
 #запишем в прологовский файл интересующие нас предикаты       
 f = "father(%r, %r).\n" % (father, child)
 m = "mother(%r, %r).\n" % (mother, child)

 out.write(f)
 out.write(m)
 ```
И закроем открытые в начале файлы

 ``` Python
out.close()
inp.close()
 ```
 
## Предикат поиска родственника

Важные моменты, связанные с моим представлением фактов на языке Prolog(используя предикаты father(отец, потомок) и mother(мать, потомок)):
1. Определение пола - был ли он/она отцом/матерью
2. Определение брака - рождение совместного ребенка 
3. Золовка - сестра мужчины, являющегося мужем

Из последнего пункта следует, что необходимо реализовать предикаты:
### 1. `spouses(X, Y)` - "X и Y состоят в браке".

Реализация этого предиката оказалась весьма простой, так как надо было только проверить наличие у этих людей совместного ребенка:
``` Prolog
spouses(X, Y):-
    father(X,_),
    mother(Y,_).
``` 

### 2. `sister(X, Y)` - "X сестра Y" 

Для реализации этого предиката необходимо было реализовать еще две пары дополнительных предикатов:

  2.1 Для понятия "братосестры" необходимо, чтобы у детей были общие родители. Это проверяют предикаты `common_father(X, Y, Z)` - "Z - общий отец для X и Y"  и `common_mother(X, Y, Z)` - "Z - общая мать для X и Y".
  ``` Prolog
  common_father(X, Y, Z):-
   father(Z, X), father(Z, Y).

  common_mother(X, Y, Z):-
   mother(Z, X), mother(Z, Y).
  ``` 
  2.2 Чтобы отличать сестру от брата реализованы предикаты `sex(X, m)` - "X - мужчина" и `sex(X, f)` -"X - женщина".
  ``` Prolog
  sex(X, m):-
   father(X, _).

  sex(X, f):-
   mother(X, _).
  ``` 
2.3 Используя созданные вспомогательные предикаты, получим предикат сестры:
``` Prolog
sister(X, Y):-
   sex(X, f),
   common_father(X, Y, _),
   common_mother(X, Y, _),
   X \= Y.
``` 
Не забываем проверить чтобы X и Y был не один и тот же человек.

### 3. Теперь все готово для написания предиката `zolovka(X, Y)` - "X - сестра мужа, Y - муж":
``` Prolog
zolovka(X, Y):-
	   sex(Y, m),
    sister(X, Y),
    spouses(Y,_).
``` 
Не забываем проверить чтобы Y был мужчиной

## Протокол работы
``` Prolog
?- common_father('Павел Попов', 'Людмила Попова', 'Иван Попов').
true.

?- common_mother('Павел Попов', 'Людмила Попова', 'Алефтина Прокудина').
true.

?- sex('Людмила Попова',f).
true.

?- sex('Павел Попов',m).
true .

?- sister('Людмила Попова', 'Павел Попов').
true.

?- zolovka('Людмила Попова', 'Павел Попов').
true .

?- zolovka('Надежда Гребенюк','Геннадий Гребенюк').
true .

?- zolovka(X,'Павел Попов').
X = 'Татьяна Попова' .

?- zolovka(X,'Геннадий Гребенюк').
X = 'Надежда Гребенюк' .

?- zolovka('Татьяна Попова',X).
X = 'Павел Попов' .

?- zolovka('Надежда Гребенюк',X).
X = 'Геннадий Гребенюк'

``` 

## Определение степени родства

Определение степени родства реализовано с использованием поиска с итерационным заглублением, так как, исходя из опыта, полученного в ходе выполнения 3 лабораторной работы, он более эффективен по памяти, нежели поиск в ширину. Результатом работы является список родственных отношений между прямыми родственниками. Прямые родственники -  люди связаны напрямую, а не через какого-то человека. Есть проверка отношений отец, мать, брат, сестра, сын, дочь, ребенок, муж, жена и, освещенная в 3 пункте, золовка. 

``` Prolog
move(X, Y, father):-father(X, Y).
move(X, Y, mother):-mother(X, Y).
move(X, Y, brother):-brother(X, Y).
move(X, Y, sister):-sister(X, Y).
move(X, Y, son):-son(X, Y).
move(X, Y, daughter):-daughter(X, Y).
move(X, Y, child):- child(X, Y).
move(X, Y, husband):-husband(X, Y).
move(X, Y, wife):-wife(X, Y).
move(X, Y, zolovka):-zolovka(X, Y).

prolong([X | T], [Y, X | T], Rel) :-
    move(X, Y, Rel),
    not(member(Y, [X | T])).

int(1).
int(M) :- int(N), M is N + 1.

depth_id([Finish | T], Finish, [Finish | T], 0, []). 
depth_id(Path, Finish, Result, N, [Rel | TRel]):- N > 0,
    prolong(Path, NewPath, Rel), N1 is N - 1,
    depth_id(NewPath, Finish, Result, N1, TRel).

search_id(Start, Finish, Path, Rel):-
    int(DepthLim),
    depth_id([Start], Finish, Path, DepthLim, Rel).

search(Start, Finish, Rel):-
    search_id(Start, Finish, _, Rel).
```

Результат работы

``` Prolog
?- search('Тамара Кокорева','Алефтина Прокудина',Res).
Res = [mother, mother, child, son] .

?- search('Людмила Попова','Илья Попов',Res).
Res = [sister, father] .

?- search('Михаил Кокорев','Алефтина Прокудина',Res).
Res = [brother, mother, mother, child, son] .

?- search('Людмила Попова','Геннадий Гребенюк',Res).
Res = [sister, husband, daughter] .
```

## Естественно-языковый интерфейс

Реализацию естественно-языкового интерфейса в данном курсовом проекте можно разбить на следующие составляющие:

1. Получение входных данных, установление типа вопроса
2. Проверка входных данных на корректность (производится путем проверки их принадлежности заранее написанным словарям)
3. Подстановка обработанных данных в предикат проверки отношений
4. Непосредственно работа предиката отношений
5. Вывод ответа пользователю

### Словари:
``` Prolog
check_relation(X):-
    member(X, [father, mother, sister, brother, son, daughter, husband, wife, zolovka]).

question_word(X):- member(X, [how, who]).
quantity(X):- member(X, [much, many]).
help_word(X):- member(X, [do, does]).
have_has(X):- member(X, [have, has]).
is(X):- member(X,[is]).
particle(X):- member(X, ["'s"]).
question_mark(X):- member(X, ['?']).
his_her(X):- member(X, [his, her, he, she]).
```

В естественно-языковом интерфейсейсе моей Prolog-программы реализованы 3 типа запросов:

### 1. Чей *указанный человек* *указанный родственник*? 
``` Prolog
question(Question):-
    Question = [NAME, WHOSE, ED_REL, QUE],
    (father(_, NAME); mother(_, NAME); father(NAME, _); mother(NAME, _)),
    %his_her(NAME) ->  nb_getval(lastName, NAME); nb_setval(lastName, NAME),
    
    question_word(WHOSE), check_relation(ED_REL), question_mark(QUE), !,
    move(NAME, Res, ED_REL),
    write(NAME),write(" is "), write(Res),write("'s "),write(ED_REL), !.
```

### 2. Кто является *указанному человеку* *указанным родственником*? 
``` Prolog
question(Question):-
    Question = [WHO, IS, NAME, PART, ED_REL, QUE],
    question_word(WHO), is(IS),
    (father(_, NAME); mother(_, NAME); father(NAME, _); mother(NAME, _)),
    %his_her(NAME) ->  nb_getval(lastName, NAME); nb_setval(lastName, NAME),
    
    particle(PART), check_relation(ED_REL), question_mark(QUE), !,
    move(Res, NAME, ED_REL),
    write(Res),write(" is "), write(NAME),write("'s "),write(ED_REL).
```

### 3. Каким родственником является *указанный человек* *указанному человеку*? 
``` Prolog
question(Question):-
    Question = [IS, NAME1, NAME2, PART, ED_REL, QUE],
    is(IS),
    (father(_, NAME1); mother(_, NAME1); father(NAME1, _); mother(NAME1, _)),
    (father(_, NAME2); mother(_, NAME2); father(NAME2, _); mother(NAME2, _)),
    particle(PART), check_relation(ED_REL), question_mark(QUE),
    move(NAME1, NAME2, ED_REL), !.
```

### 4. Сколько *указанных родственников* имеет *указанный человек*? 
``` Prolog
%предикаты для определения множественного числа для предиката проверки отношений
purals(X):- member(X, [sisters, brothers, sons, daughters]).
pural(sister, sisters).
pural(brother, brothers).
pural(son, sons).
pural(daughter, daughters).

question(Question):-
    Question = [HOW, MANY, MN_REL, D, NAME, H, QUE],
    
    question_word(HOW), quantity(MANY), purals(MN_REL), help_word(D),
    (father(_, NAME); mother(_, NAME); father(NAME, _); mother(NAME, _)),
    %his_her(NAME) ->  nb_getval(lastName, NAME); nb_setval(lastName, NAME),
    have_has(H), question_mark(QUE),

    pural(ED_REL, MN_REL), !,
    setof(X, move(X, NAME, ED_REL), LRes), 
    length(LRes, Res), !,
    
    write(NAME), write(" have "),
    ((Res =:= 1,write(Res),write(" "),write( ED_REL));
    (\+(Res =:= 1),write(Res), write(" "), write(MN_REL))), !.
```

Результат работы

``` Prolog
?- question([who, is, 'Ирина Гребенюк', "'s", mother,?]).
Тамара Кокорева is Ирина Гребенюк's mother
true .

?- question([is, 'Ирина Гребенюк', 'Тамара Кокорева',"'s", X,?]).
X = daughter.

?- question([how,many,brothers,does,'Василий Кокорев',have,?]).
Василий Кокорев have 3 brothers
true .

```

## Выводы

В ходе данного курсового проекта мне представилась возможность решения реальной практической задачи на логическом языке - Prolog. Это был хороший опыт выполнения многоуровневого проекта, состоящего из следующих этапов:
1. Построение генеалогического дерева своей семьи
2. Написание парсера для перевода дерева из GED файла в файл фактов на языке Prolog
3. Реализация предикат определения родственника(золовки)
4. Реализация возможности определение степени родства двух произвольных индивидуумов в дереве
5. Реализация естественно-языкового интерфейса к системе, позволяющего задавать вопросы относительно степеней родства, и получать осмысленные ответы

Хотелось бы отметить, что при самостоятельном выполнении проетов такого рода, где затрагиваются несколько областей знаний, на один уровень по важности с работоспособностью программы встает удобство внесения в нее изменений, поэтому код изначально стоит писать достаточно гибко, чтобы в дальнейшем не возникло трудностей.

Также этот проект стал неким сборником знаний, полученных на курсе, наиболее красочно это иллюстрирует поиск в генеалогическом дереве для определения степени родства двух произвольных индивидуумов. В лабораторной работе №3 было установлено, что наиболее удобеный алгоритм поиска в подобных деревьях (достаточно глубоких, глубина моего - 6 поколений) - поиск с итерационным заглублением, так как он, подобно поиску в глубину, который лежит в его основе, эффективен по памяти и подобно поиску в ширину первым находит кратчайшее решение. 

Данный курсовой проект дал прочувствовать силу логической парадигмы программирования в ее основной среде востребования - постройка деревьев, в данном случае - генеалогических.
Также написание парсера на Python было неплохой тренировкой и закреплением навыков программирования на этом языке.

Однако самая приятная его часть - это составление дерева совместно со своими родственниками.
