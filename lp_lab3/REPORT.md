#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Попов И. П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   24.12      |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Разнообразные задачи, в том числе и логические, можно решить задав для них пространство состояний в виде графа, который должен включать в себя:

1. Вершины - структурные термы, описывающие различные состояния
2. Ребра - правила перемещения между состояниями
3. Начальное и конечное состояние
4. Путь из начального состояния в конечное - решение задачи

Основное удобство Prolog'а для решения таких задач состоит в простоте реализации поиска пути из начального состояния в конечное. Это обусловлено тем, что Prolog сам строит дерево всевозможных состояний, а механизм бектрекинга очень удобен при поиске в глубину и поиске с итеративным погружением.

В данной лабораторной работе рассмотрены следующие алгоритмы поиска: в глубину, в ширину, с итеративным погружением
В дальнейшем будут рассмотрены преимущества и недостатки каждого.

## Задание

2. Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении, если в их распоряжении имеется трехместная лодка и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

Задание пространства состояний

### 1. Вершины

Cтруктурный терм `s(MLeft, KLeft, boat_pos, MRight, KRight)` описывает одно из состояний пространства
1. MLeft - Кол-во миссионеров на левом берегу 
2. KLeft - Кол-во каннибалов на левом берегу 
3. boat_pos - Положение лодки (левый/правый берег)
4. MRight- Кол-во миссионеров на правом берегу 
5. KRight- Кол-во каннибалов на правом берегу

### 2. Дуги

Изменение состояний производится за счет "рейса" лодки на другой берег
```prolog
%проверка на удовлетворение условиям безопасности для миссионеров на обоих берегах
check(M, K) :-
    M >= K; M =:= 0. 
    
%варианты размещения в лодке миссионеров(слева) и каннибалов(справа) 
boat_state(1, 0).
boat_state(2, 0).
boat_state(3, 0).
boat_state(0, 1).
boat_state(0, 2).
boat_state(0, 3).
boat_state(1, 1).
boat_state(2, 1).

%"рейс" с левого берега на правый
move(s(MLeft1, KLeft1, left, MRight1, KRight1), s(MLeft2, KLeft2, right, MRight2, KRight2)) :-
    %нам надо подобрать такую комбинацию людей в лодке, чтобы выполнялось условие безопасности миссионеров
    boat_state(M, K), M =< MLeft1, K =< KLeft1,
    MLeft2 is MLeft1 - M, KLeft2 is KLeft1 - K,
    check(MLeft2, KLeft2),
    MRight2 is MRight1 + M, KRight2 is KRight1 + K,
    check(MRight2, KRight2).

%"рейс" с правого берега на левый
move(s(MLeft1, KLeft1, right, MRight1, KRight1), s(MLeft2, KLeft2, left, MRight2, KRight2)) :-
    move(s(MRight1, KRight1, left, MLeft1, KLeft1), s(MRight2, KRight2, right, MLeft2, KLeft2)).
```

### 3. Начальное и конечное состояния
```prolog
%стартовое состояние - все на левом берегу
start(s(3,3, left, 0, 0)).

%конечное состояние - все на левом берегу
goal(s(_ ,_ ,_ , 3, 3)).
```
Теперь, когда пространство состояний задано, рассмотрим алгоритмы поиска в графе. Все алгоритмы используют предикат продления пути из определенного состояния prolong:
```prolog
prolong([X | T], [Y, X | T]) :-
    move(X, Y),
    not(member(Y, [X | T])).
```

### 1. Поиск в глубину
Особенности:

1. Первым находится не обязательно кратчайший путь
2. Даже если есть короткий путь к решению, он может быть не найден, а будут рассматриваться длинные тупиковые ветки
3. Расход по памяти - O(l), где l - длина рассматриваемого пути

```prolog
dpth([X | T], [X | T]) :-
    goal(X).
dpth(P, L) :-
    prolong(P, P1),
    dpth(P1, L).
```

### 2. Поиск в ширину
Особенности:

1. Первым находится кратчайший путь
2. Имеет больший расход по памяти, нежели другие рассмотренные виды поиска, так как хранит очередь путей 
3. Может использоваться для нахождений путей с циклами

```prolog
bdth([[X | T] | _], [X | T]) :-
    goal(X).
bdth([P | Q1], R) :-
    findall(Z, prolong(P, Z), T),
    append(Q1, T, Q0), !,
    bdth(Q0, R).

```

### 3. Поиск с итеративным погружением

Сочетает в себе преимуществ первых двух алгоритмов: эффективность по памяти от поиска в глубину и нахождение кратчайшего пути первым от поиска в ширину

Особенности:

1. Сложность O(b^l), где l - длина рассматриваемого пути
2. По сложности не сильно превосходят поиск в ширину, сохраняя все его положительные стороны исключая требования к памяти 
```prolog
int(1).
int(M) :-
    int(N), M is N + 1.

depth_id([X | T], [X | T], 0) :- %отсечение путей, которые не соответствуют заданной глубине
    goal(X).
depth_id(P, L, N) :- N > 0,
    prolong(P, P1), N1 is N - 1,
    depth_id(P1, L, N1).
```

## Результаты

Предикаты выводят все состояния системы от начальной до конечной, а также время затраченное на поиск и длину найденного пути:

```prolog
?- search_dpth.
1). s(3,3,left,0,0)
2). s(3,1,right,0,2)
3). s(3,2,left,0,1)
4). s(0,2,right,3,1)
5). s(2,2,left,1,1)
6). s(1,1,right,2,2)
7). s(3,1,left,0,2)
8). s(0,1,right,3,2)
9). s(1,1,left,2,2)
10). s(0,0,right,3,3)

Depth-search length: 10
Depth-search time: 0.00016260147094726562

true.

?- search_bdth.
1). s(3,3,left,0,0)
2). s(3,1,right,0,2)
3). s(3,2,left,0,1)
4). s(0,2,right,3,1)
5). s(0,3,left,3,0)
6). s(0,0,right,3,3)

Breadth-search length: 6
Breadth-search time: 0.0005815029144287109

true.

?- search_id.
1). s(3,3,left,0,0)
2). s(3,1,right,0,2)
3). s(3,2,left,0,1)
4). s(0,2,right,3,1)
5). s(0,3,left,3,0)
6). s(0,0,right,3,3)

Breadth-search length: 6
Breadth-search time: 0.0003018379211425781

true.

```

| Алгоритм поиска |  Длина найденного первым пути  |     Время работы    |
|-----------------|--------------------------------|---------------------|
| В глубину       |              10               | 0.00016260147094726562 |
| В ширину        |               6               | 0.0005815029144287109  |
| ID              |               6               | 0.0003018379211425781 |

## Выводы

Данная лабораторная работа познакомила меня с новым способом решения логических задач - с помощью пространства состояний, которое мжет быть реализовано в виде графа, вершины которого являются состояниями системы, дуги - правилами перемещения между ними. С помощью алгоритмов поиска мы можем найти путь из начального состояния в конечное, он и будет решением задачи. 

Конкретно для моей задачи лучший результат показал алгоритм поиска в глубину, он является естественным для языка Prolog, поэтому поиск в глубину путей на графах реализуется наиболее просто. Однако, поиск в глубину нашел далеко не самый короткий путь решения задачи, и, если бы пространство состояний было обширнее (хорошим примером будет являться пространство состояний кубика-Рубика), то этот алгоритм оказался бы не столь эффективным.

Поиск в ширину устроен сложнее, чем поиск в глубину, ему необходимо хранить информацию о всех возможных состояниях, в которые он может попасть из ткущего, что придает ему экспоненциальную сложность, как по памяти, так и по времени.

Поиск с итерационным заглублением взял лучшее от своих товарищей, и для решения задач с большим пространством состояний будет являться наиболее эффективным алгоритмом поиска, так как он, подобно поиску в глубину, который лежит в его основе, эффективен по памяти и подобно поиску в ширину первым находит кратчайшее решение.



